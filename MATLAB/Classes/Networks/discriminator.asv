%{
        Class for Discriminator

        Jashua Luna
        October 2022
%}

classdef discriminator < DeepNetwork
    %{
        This network analyzes the spectral content of an input signal to
        determine if it is real o

    %}

    properties

    end

    methods 
        function obj = discriminator(LayerSizes,WindowSize)
            % constructor
            
            obj.info.WindowSize = WindowSize;                                       % store windowsize in network's info
            
            [~,obj.info.WTL] = obj.init_waveletlayer;                               % initialize wavelet layer
                
            [obj.weights.PL,obj.info.PL] = obj.init_predictionlayer(LayerSizes.PL); % init prediction layer
        end

        %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %
        %   Layer Functions

        function dly = predict(obj,dlx)
            % function for forward pass on discriminator

            obj.debug_info("<strong>Prediction Layer</strong>",[]);                         % display active layer's name while in debug

            dly = obj.waveletlayer(dlx);                                                    % wavelet transform input data
            
            for i = 1:obj.info.nBlocks                                                      % loop through blocks
                dly = conv_maxpool(obj,dropout(dly),obj.weights.blocks{i},@relu);           % convolution x2 + maxpool blocks

                debug_message = append("Output size after ",num2str(i)," iterations ");     % debug message
                obj.debug_info(debug_message,info);                                         % display layer output size 
            end

            function dly = conv_maxpool(dlx,layer,activation)   
                % function for convolution x2 + maxpool layer 

                dly = obj.convlayer(dlx,layer.cn2d1,'DataFormat','SSCB');           % first 2D conv layer
                dly = activation(dly);                                             % activation layer

                dly = obj.convlayer(dly,layer.cn2d2,'DataFormat','SSCB');           % second 2D conv layer
                dly = activation(dly);                                              % activation layer
                
                dly = obj.batchnormlayer(dly,layer.bn1,'DataFormat','SSCB');        % batch norm layer               
            end
        end

        function [dly] = waveletlayer(obj,dlx)
            % layer to wavelet transform input data

            obj.debug_info("<strong>Wavelet Layer</strong>",[]);                                    % display active layer's name while in debug

            dly = dlcwt(dlx,obj.info.WTL.psi_fvec,obj.info.WTL.filter_idx,'DataFormat','TCB');      % Wavelet transform subsampled sets
            dly = permute(dly,[1 4 2 3]);                                                           % dlcwt output is SCBT where S is filter dilation, permute to STCB

            obj.debug_info("Output size after Wavelet Layer: ",dly);                                % display layer output size
        end

        %~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        %
        %   Layer initialization functions

        function [layer,info] = init_waveletlayer(obj)
            % function for initializing wavelet layer

            wavelet = cwtfilterbank('SignalLength',obj.info.WindowSize,'Boundary','periodic');
            [info.psi_fvec,info.filter_idx] = cwtfilter2array(wavelet);

            layer = [];
        end

        function [layer,info] = init_predictionlayer(obj,layersizes)
            % init prediction layer
            
            info.nBlocks = .5*size(layersizes,1);
            assert(rem(info.IE.nBlocks,1)==0,"rows in layersizes must be a factor of two");

            layer.blocks = cell(info.nBlocks,1);
            for i = 1:info.nBlocks
                layer.blocks{i} = init_predictionlayerblock()
            




        end
    end
end 